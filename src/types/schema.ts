/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/public/Time": {
    /** Get the server's time. */
    get: operations["getServerTime"];
  };
  "/public/SystemStatus": {
    /** Get the current system status or trading mode. */
    get: operations["getSystemStatus"];
  };
  "/public/Assets": {
    /** Get information about the assets that are available for deposit, withdrawal, trading and staking. */
    get: operations["getAssetInfo"];
  };
  "/public/AssetPairs": {
    /** Get tradable asset pairs */
    get: operations["getTradableAssetPairs"];
  };
  "/public/Ticker": {
    /** Note: Today's prices start at midnight UTC */
    get: operations["getTickerInformation"];
  };
  "/public/OHLC": {
    /** Note: the last entry in the OHLC array is for the current, not-yet-committed frame and will always be present, regardless of the value of `since`. */
    get: operations["getOHLCData"];
  };
  "/public/Depth": {
    get: operations["getOrderBook"];
  };
  "/public/Trades": {
    /** Returns the last 1000 trades by default */
    get: operations["getRecentTrades"];
  };
  "/public/Spread": {
    get: operations["getRecentSpreads"];
  };
  "/private/GetWebSocketsToken": {
    /**
     * An authentication token must be requested via this REST API endpoint in order to connect to and authenticate with our [Websockets API](https://docs.kraken.com). The token should be used within 15 minutes of creation, but it does not expire once a successful Websockets connection and private subscription has been made and is maintained.
     *
     * > The 'Access WebSockets API' permission must be enabled for the API key in order to generate the authentication token.
     */
    post: operations["getWebsocketsToken"];
  };
  "/private/Balance": {
    /** Retrieve all cash balances, net of pending withdrawals. */
    post: operations["getAccountBalance"];
  };
  "/private/TradeBalance": {
    /** Retrieve a summary of collateral balances, margin position valuations, equity and margin level. */
    post: operations["getTradeBalance"];
  };
  "/private/OpenOrders": {
    /** Retrieve information about currently open orders. */
    post: operations["getOpenOrders"];
  };
  "/private/ClosedOrders": {
    /**
     * Retrieve information about orders that have been closed (filled or cancelled). 50 results are returned at a time, the most recent by default.
     *
     * **Note:** If an order's tx ID is given for `start` or `end` time, the order's opening time (`opentm`) is used
     */
    post: operations["getClosedOrders"];
  };
  "/private/QueryOrders": {
    /** Retrieve information about specific orders. */
    post: operations["getOrdersInfo"];
  };
  "/private/TradesHistory": {
    /**
     * Retrieve information about trades/fills. 50 results are returned at a time, the most recent by default.
     * * Unless otherwise stated, costs, fees, prices, and volumes are specified with the precision for the asset pair (`pair_decimals` and `lot_decimals`), not the individual assets' precision (`decimals`).
     */
    post: operations["getTradeHistory"];
  };
  "/private/QueryTrades": {
    /** Retrieve information about specific trades/fills. */
    post: operations["getTradesInfo"];
  };
  "/private/OpenPositions": {
    /** Get information about open margin positions. */
    post: operations["getOpenPositions"];
  };
  "/private/Ledgers": {
    /** Retrieve information about ledger entries. 50 results are returned at a time, the most recent by default. */
    post: operations["getLedgers"];
  };
  "/private/QueryLedgers": {
    /** Retrieve information about specific ledger entries. */
    post: operations["getLedgersInfo"];
  };
  "/private/TradeVolume": {
    /** Note: If an asset pair is on a maker/taker fee schedule, the taker side is given in `fees` and maker side in `fees_maker`. For pairs not on maker/taker, they will only be given in `fees`. */
    post: operations["getTradeVolume"];
  };
  "/private/AddExport": {
    /** Request export of trades or ledgers. */
    post: operations["addExport"];
  };
  "/private/ExportStatus": {
    /** Get status of requested data exports. */
    post: operations["exportStatus"];
  };
  "/private/RetrieveExport": {
    /** Retrieve a processed data export */
    post: operations["retrieveExport"];
  };
  "/private/RemoveExport": {
    /** Delete exported trades/ledgers report */
    post: operations["removeExport"];
  };
  "/private/AddOrder": {
    /**
     * Place a new order.
     *
     * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
     */
    post: operations["addOrder"];
  };
  "/private/AddOrderBatch": {
    /**
     * Send an array of orders (max: 15).
     * Any orders rejected due to order validations, will be dropped and the rest of the batch is processed. All orders in batch should be limited to a single pair.
     * The order of returned txid's in the response array is the same as the order of the order list sent in request.
     *
     * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
     */
    post: operations["addOrderBatch"];
  };
  "/private/EditOrder": {
    /**
     * Edit volume and price on open orders. Uneditable orders include margin orders, triggered stop/profit orders, orders with conditional close terms attached, those already cancelled or filled, and those where the executed volume is greater than the newly supplied volume. post-only flag is not retained from original order after successful edit. post-only needs to be explicitly set on edit request.
     *
     * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
     */
    post: operations["editOrder"];
  };
  "/private/CancelOrder": {
    /** Cancel a particular open order (or set of open orders) by `txid` or `userref` */
    post: operations["cancelOrder"];
  };
  "/private/CancelAll": {
    /** Cancel all open orders */
    post: operations["cancelAllOrders"];
  };
  "/private/CancelAllOrdersAfter": {
    /**
     * CancelAllOrdersAfter provides a "Dead Man's Switch" mechanism to protect the client from network malfunction, extreme latency or unexpected matching engine downtime. The client can send a request with a timeout (in seconds), that will start a countdown timer which will cancel *all* client orders when the timer expires. The client has to keep sending new requests to push back the trigger time, or deactivate the mechanism by specifying a timeout of 0. If the timer expires, all orders are cancelled and then the timer remains disabled until the client provides a new (non-zero) timeout.
     *
     * The recommended use is to make a call every 15 to 30 seconds, providing a timeout of 60 seconds. This allows the client to keep the orders in place in case of a brief disconnection or transient delay, while keeping them safe in case of a network breakdown. It is also recommended to disable the timer ahead of regularly scheduled trading engine maintenance (if the timer is enabled, all orders will be cancelled when the trading engine comes back from downtime - planned or otherwise).
     */
    post: operations["cancelAllOrdersAfter"];
  };
  "/private/CancelOrderBatch": {
    /** Cancel multiple open orders  by `txid` or `userref` */
    post: operations["cancelOrderBatch"];
  };
  "/private/DepositMethods": {
    /** Retrieve methods available for depositing a particular asset. */
    post: operations["getDepositMethods"];
  };
  "/private/DepositAddresses": {
    /** Retrieve (or generate a new) deposit addresses for a particular asset and method. */
    post: operations["getDepositAddresses"];
  };
  "/private/DepositStatus": {
    /** Retrieve information about recent deposits made. */
    post: operations["getStatusRecentDeposits"];
  };
  "/private/WithdrawInfo": {
    /** Retrieve fee information about potential withdrawals for a particular asset, key and amount. */
    post: operations["getWithdrawalInformation"];
  };
  "/private/Withdraw": {
    /** Make a withdrawal request. */
    post: operations["withdrawFunds"];
  };
  "/private/WithdrawStatus": {
    /** Retrieve information about recently requests withdrawals. */
    post: operations["getStatusRecentWithdrawals"];
  };
  "/private/WithdrawCancel": {
    /** Cancel a recently requested withdrawal, if it has not already been successfully processed. */
    post: operations["cancelWithdrawal"];
  };
  "/private/WalletTransfer": {
    /** Transfer from Kraken spot wallet to Kraken Futures holding wallet. Note that a transfer in the other direction must be requested via the Kraken Futures [API endpoint](https://support.kraken.com/hc/en-us/articles/360028105972-Withdrawal-to-Spot-Wallet). */
    post: operations["walletTransfer"];
  };
  "/private/Stake": {
    /** Stake an asset from your spot wallet. This operation requires an API key with `Withdraw funds` permission. */
    post: operations["stake"];
  };
  "/private/Unstake": {
    /** Unstake an asset from your staking wallet. This operation requires an API key with `Withdraw funds` permission. */
    post: operations["unstake"];
  };
  "/private/Staking/Assets": {
    /**
     * Returns the list of assets that the user is able to stake. This operation
     * requires an API key with both `Withdraw funds` and `Query funds` permission.
     */
    post: operations["getStakingAssetInfo"];
  };
  "/private/Staking/Pending": {
    /**
     * Returns the list of pending staking transactions. Once resolved, these transactions
     * will appear on the `List of Staking Transactions` endpoint.
     *
     * This operation requires an API key with both `Query funds` and `Withdraw funds` permissions.
     */
    post: operations["getStakingPendingDeposits"];
  };
  "/private/Staking/Transactions": {
    /**
     * Returns the list of 1000 recent staking transactions from past 90 days.
     *
     * This operation requires an API key with `Query funds` permissions.
     */
    post: operations["getStakingTransactions"];
  };
}

export interface components {
  schemas: {
    error: string[];
    /** @description Success response */
    time: {
      /** ServerTime */
      result?: {
        /** @description Unix timestamp */
        unixtime?: number;
        /** @description RFC 1123 time format */
        rfc1123?: string;
      };
      error?: components["schemas"]["error"];
    };
    /**
     * AssetInfo
     * @description Asset Info
     */
    info: {
      /** @description Asset Class */
      aclass?: string;
      /** @description Alternate name */
      altname?: string;
      /** @description Scaling decimal places for record keeping */
      decimals?: number;
      /** @description Scaling decimal places for output display */
      display_decimals?: number;
    };
    "info-2": {
      result?: { [key: string]: components["schemas"]["info"] };
      error?: components["schemas"]["error"];
    };
    /**
     * AssetPair
     * @description Trading Asset Pair
     */
    pairs: {
      /** @description Alternate pair name */
      altname?: string;
      /** @description WebSocket pair name (if available) */
      wsname?: string;
      /** @description Asset class of base component */
      aclass_base?: string;
      /** @description Asset ID of base component */
      base?: string;
      /** @description Asset class of quote component */
      aclass_quote?: string;
      /** @description Asset ID of quote component */
      quote?: string;
      /**
       * @deprecated
       * @description Volume lot size
       */
      lot?: string;
      /** @description Scaling decimal places for pair */
      pair_decimals?: number;
      /** @description Scaling decimal places for volume */
      lot_decimals?: number;
      /** @description Amount to multiply lot volume by to get currency volume */
      lot_multiplier?: number;
      /** @description Array of leverage amounts available when buying */
      leverage_buy?: number[];
      /** @description Array of leverage amounts available when selling */
      leverage_sell?: number[];
      /** @description Fee schedule array in `[<volume>, <percent fee>]` tuples */
      fees?: number[][];
      /** @description Maker fee schedule array in `[<volume>, <percent fee>]`  tuples (if on maker/taker) */
      fees_maker?: number[][];
      /** @description Volume discount currency */
      fee_volume_currency?: string;
      /** @description Margin call level */
      margin_call?: number;
      /** @description Stop-out/liquidation margin level */
      margin_stop?: number;
      /** @description Minimum order size (in terms of base currency) */
      ordermin?: string;
    };
    /**
     * AssetTickerInfo
     * @description Asset Ticker Info
     */
    ticker: {
      /** @description Ask `[<price>, <whole lot volume>, <lot volume>]` */
      a?: string[];
      /** @description Bid `[<price>, <whole lot volume>, <lot volume>]` */
      b?: string[];
      /** @description Last trade closed `[<price>, <lot volume>]` */
      c?: string[];
      /** @description Volume `[<today>, <last 24 hours>]` */
      v?: string[];
      /** @description Volume weighted average price `[<today>, <last 24 hours>]` */
      p?: string[];
      /** @description Number of trades `[<today>, <last 24 hours>]` */
      t?: number[];
      /** @description Low `[<today>, <last 24 hours>]` */
      l?: string[];
      /** @description High `[<today>, <last 24 hours>]` */
      h?: string[];
      /** @description Today's opening price */
      o?: string;
    };
    "ticker-2": {
      result?: { [key: string]: components["schemas"]["ticker"] };
      error?: components["schemas"]["error"];
    };
    /**
     * TickData
     * @description Array of tick data arrays
     * `[int <time>, string <open>, string <high>, string <low>, string <close>, string <vwap>, string <volume>, int <count>]`
     */
    tickData: (string | number)[][];
    ohlc: {
      result?: {
        /** @description ID to be used as since when polling for new, committed OHLC data */
        last?: number;
      } & { [key: string]: components["schemas"]["tickData"] };
      error?: components["schemas"]["error"];
    };
    /**
     * OrderBook
     * @description Asset Pair Order Book Entries
     */
    orderBookEntry: {
      /** @description Ask side array of entries `[<price>, <volume>, <timestamp>]` */
      asks?: (string | number)[];
      /** @description Bid side array of entries `[<price>, <volume>, <timestamp>]` */
      bid?: (string | number)[];
    };
    depth: {
      result?: { [key: string]: components["schemas"]["orderBookEntry"] };
      error?: components["schemas"]["error"];
    };
    /**
     * TickData
     * @description Array of trade entries
     * `[<price>, <volume>, <time>, <buy/sell>, <market/limit>, <miscellaneous>]`
     */
    trade: (string | number)[];
    trades: {
      result?: {
        /** @description ID to be used as since when polling for new trade data */
        last?: string;
      } & { [key: string]: components["schemas"]["trade"] };
      error?: components["schemas"]["error"];
    };
    /**
     * SpreadData
     * @description Array of spread entries
     * `[int <time>, string <bid>, string <ask>]`
     */
    spread: (string | number)[];
    "spread-2": {
      result?: {
        /** @description ID to be used as since when polling for new spread data */
        last?: number;
      } & { [key: string]: components["schemas"]["spread"][] };
      error?: components["schemas"]["error"];
    };
    /**
     * Format: int32
     * @description Nonce used in construction of `API-Sign` header
     */
    nonce: number;
    /**
     * AccountBalance
     * @description Account Balance
     * @example {
     *   "ZUSD": "2970172.7962"
     * }
     */
    balance: { [key: string]: string };
    "balance-2": {
      result?: components["schemas"]["balance"];
      error?: components["schemas"]["error"];
    };
    /**
     * AccountBalance
     * @description Account Balance
     */
    "balance-3": {
      /**
       * @description Equivalent balance (combined balance of all currencies)
       * @example 3224744.0162
       */
      eb?: string;
      /**
       * @description Trade balance (combined balance of all equity currencies)
       * @example 3224744.0162
       */
      tb?: string;
      /**
       * @description Margin amount of open positions
       * @example 0.0000
       */
      m?: string;
      /**
       * @description Unrealized net profit/loss of open positions
       * @example 0.0000
       */
      n?: string;
      /**
       * @description Cost basis of open positions
       * @example 0.0000
       */
      c?: string;
      /**
       * @description Current floating valuation of open positions
       * @example 0.0000
       */
      v?: string;
      /**
       * @description Equity: `trade balance + unrealized net profit/loss`
       * @example 3224744.0162
       */
      e?: string;
      /**
       * @description Free margin: `Equity - initial margin (maximum margin available to open new positions)`
       * @example 3224744.0162
       */
      mf?: string;
      /** @description Margin level: `(equity / initial margin) * 100` */
      ml?: string;
    };
    "balance-4": {
      result?: components["schemas"]["balance-3"];
      error?: components["schemas"]["error"];
    };
    /**
     * @description Order type
     *
     * @enum {string}
     */
    ordertype:
      | "market"
      | "limit"
      | "stop-loss"
      | "take-profit"
      | "stop-loss-limit"
      | "take-profit-limit"
      | "settle-position";
    /**
     * @description Comma delimited list of order flags
     *
     *   * `post` post-only order (available when ordertype = limit)
     *   * `fcib` prefer fee in base currency (default if selling)
     *   * `fciq` prefer fee in quote currency (default if buying, mutually exclusive with `fcib`)
     *   * `nompp` disable [market price protection](https://support.kraken.com/hc/en-us/articles/201648183-Market-Price-Protection) for market orders
     *   * `viqc`  order volume expressed in quote currency. This is supported only for market orders.
     */
    oflags: string;
    /**
     * OpenOrder
     * @description Open Order
     */
    order: {
      /** @description Referral order transaction ID that created this order */
      refid?: string;
      /** @description User reference id */
      userref?: string;
      /**
       * @description Status of order
       *   * pending = order pending book entry
       *   * open = open order
       *   * closed = closed order
       *   * canceled = order canceled
       *   * expired = order expired
       *
       * @enum {string}
       */
      status?: "pending" | "open" | "closed" | "canceled" | "expired";
      /** @description Unix timestamp of when order was placed */
      opentm?: number;
      /** @description Unix timestamp of order start time (or 0 if not set) */
      starttm?: number;
      /** @description Unix timestamp of order end time (or 0 if not set) */
      expiretm?: number;
      /**
       * OrderDescription
       * @description Order description info
       */
      descr?: {
        /** @description Asset pair */
        pair?: string;
        /**
         * @description Type of order (buy/sell)
         * @enum {string}
         */
        type?: "buy" | "sell";
        ordertype?: components["schemas"]["ordertype"];
        /** @description primary price */
        price?: string;
        /** @description Secondary price */
        price2?: string;
        /** @description Amount of leverage */
        leverage?: string;
        /** @description Order description */
        order?: string;
        /** @description Conditional close order description (if conditional close set) */
        close?: string;
      };
      /** @description Volume of order (base currency) */
      vol?: string;
      /** @description Volume executed (base currency) */
      vol_exec?: string;
      /** @description Total cost (quote currency unless) */
      cost?: string;
      /** @description Total fee (quote currency) */
      fee?: string;
      /** @description Average price (quote currency) */
      price?: string;
      /** @description Stop price (quote currency) */
      stopprice?: string;
      /** @description Triggered limit price (quote currency, when limit based order type triggered) */
      limitprice?: string;
      /**
       * @description Price signal used to trigger "stop-loss" "take-profit" "stop-loss-limit" "take-profit-limit" orders.
       *   * `last` is the implied trigger if this field is not set.
       *
       * @default last
       * @enum {string}
       */
      trigger?: "last" | "index";
      /**
       * @description Comma delimited list of miscellaneous info
       *
       *   * `stopped` triggered by stop price
       *   * `touched` triggered by touch price
       *   * `liquidated` liquidation
       *   * `partial` partial fill
       */
      misc?: string;
      oflags?: components["schemas"]["oflags"];
      /** @description List of trade IDs related to order (if trades info requested and data available) */
      trades?: string[];
    };
    /**
     * OpenOrder
     * @description Open Order
     */
    open: components["schemas"]["order"];
    "open-2": {
      /**
       * OpenOrders
       * @description Open Orders
       */
      result?: {
        open?: { [key: string]: components["schemas"]["open"] };
      };
      error?: components["schemas"]["error"];
    };
    /**
     * ClosedOrder
     * @description Closed Order
     */
    closed: components["schemas"]["order"] & {
      /** @description Unix timestamp of when order was closed */
      closetm?: number;
      /** @description Additional info on status (if any) */
      reason?: string;
    };
    "closed-2": {
      /**
       * ClosedOrders
       * @description Closed Orders
       */
      result?: {
        closed?: { [key: string]: components["schemas"]["closed"] };
        /** @description Amount of available order info matching criteria */
        count?: number;
      };
      error?: components["schemas"]["error"];
    };
    /** Query Orders Info Request Body */
    query: {
      nonce: components["schemas"]["nonce"];
      /**
       * @description Whether or not to include trades related to position in output
       * @default false
       */
      trades?: boolean;
      /**
       * Format: int32
       * @description Restrict results to given user reference id
       */
      userref?: number;
      /** @description Comma delimited list of transaction IDs to query info about (50 maximum) */
      txid: string;
    };
    "query-2": {
      result?: {
        [key: string]:
          | components["schemas"]["open"]
          | components["schemas"]["closed"];
      };
      error?: components["schemas"]["error"];
    };
    /**
     * Trade
     * @description Trade Info
     */
    "trade-2": {
      /** @description Order responsible for execution of trade */
      ordertxid?: string;
      /** @description Asset pair */
      pair?: string;
      /** @description Unix timestamp of trade */
      time?: number;
      /** @description Type of order (buy/sell) */
      type?: string;
      /** @description Order type */
      ordertype?: string;
      /** @description Average price order was executed at (quote currency) */
      price?: string;
      /** @description Total cost of order (quote currency) */
      cost?: string;
      /** @description Total fee (quote currency) */
      fee?: string;
      /** @description Volume (base currency) */
      vol?: string;
      /** @description Initial margin (quote currency) */
      margin?: string;
      /**
       * @description Comma delimited list of miscellaneous info:
       * * `closing` &mdash; Trade closes all or part of a position
       */
      misc?: string;
      /**
       * @description Position status (open/closed)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      posstatus?: string;
      /**
       * @description Average price of closed portion of position (quote currency)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      cprice?: unknown;
      /**
       * @description Total cost of closed portion of position (quote currency)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      ccost?: unknown;
      /**
       * @description Total fee of closed portion of position (quote currency)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      cfee?: unknown;
      /**
       * @description Total fee of closed portion of position (quote currency)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      cvol?: unknown;
      /**
       * @description Total margin freed in closed portion of position (quote currency)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      cmargin?: unknown;
      /**
       * @description Net profit/loss of closed portion of position (quote currency, quote currency scale)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      net?: unknown;
      /**
       * @description List of closing trades for position (if available)
       * <br><sub><sup>Only present if trade opened a position</sub></sup>
       */
      trades?: string[];
    };
    /**
     * TradeHistory
     * @description Trade History
     */
    history: {
      /** @description Trade info */
      trades?: { [key: string]: components["schemas"]["trade-2"] };
      /** @description Amount of available trades matching criteria */
      count?: number;
    };
    "history-2": {
      result?: components["schemas"]["history"];
      error?: components["schemas"]["error"];
    };
    /**
     * LedgerEntry
     * @description Ledger Entry
     */
    ledger: {
      /** @description Reference Id */
      refid?: string;
      /** @description Unix timestamp of ledger */
      time?: number;
      /**
       * @description Type of ledger entry
       * @enum {string}
       */
      type?:
        | "trade"
        | "deposit"
        | "withdrawal"
        | "transfer"
        | "margin"
        | "rollover"
        | "spend"
        | "receive"
        | "settled"
        | "adjustment";
      /** @description Additional info relating to the ledger entry type, where applicable */
      subtype?: string;
      /** @description Asset class */
      aclass?: string;
      /** @description Asset */
      asset?: string;
      /** @description Transaction amount */
      amount?: string;
      /** @description Transaction fee */
      fee?: string;
      /** @description Resulting balance */
      balance?: string;
    };
    "info-3": {
      /**
       * LedgersInfo
       * @description Ledgers Info
       */
      result?: {
        ledger?: { [key: string]: components["schemas"]["ledger"] };
        /** @description Amount of available ledger info matching criteria */
        count?: number;
      };
      error?: components["schemas"]["error"];
    };
    "query-3": {
      result?: { [key: string]: components["schemas"]["ledger"] };
      error?: components["schemas"]["error"];
    };
    /**
     * FeeTierInfo
     * @description Fee Tier Info
     */
    fees: {
      /** @description Current fee (in percent) */
      fee?: string;
      /** @description minimum fee for pair (if not fixed fee) */
      min_fee?: string;
      /** @description maximum fee for pair (if not fixed fee) */
      max_fee?: string;
      /** @description next tier's fee for pair (if not fixed fee,  null if at lowest fee tier) */
      next_fee?: string | null;
      /** @description volume level of current tier (if not fixed fee. null if at lowest fee tier) */
      tier_volume?: string | null;
      /** @description volume level of next tier (if not fixed fee. null if at lowest fee tier) */
      next_volume?: string | null;
    };
    volume: {
      /**
       * TradeVolume
       * @description Trade Volume
       */
      result?: {
        /** @description Volume currency */
        currency?: string;
        /** @description Current discount volume */
        volume?: string;
        fees?: { [key: string]: components["schemas"]["fees"] };
        fees_maker?: { [key: string]: components["schemas"]["fees"] };
      };
      error?: components["schemas"]["error"];
    };
    /** Add Standard Order Request Body */
    add: {
      nonce: components["schemas"]["nonce"];
      /**
       * Format: int32
       * @description User reference id
       *
       * `userref` is an optional user-specified integer id that can be associated with any number of orders. Many clients choose a `userref` corresponding to a unique integer id generated by their systems (e.g. a timestamp). However, because we don't enforce uniqueness on our side, it can also be used to easily group orders by pair, side, strategy, etc. This allows clients to more readily cancel or query information about orders in a particular group, with fewer API calls by using `userref` instead of our `txid`, where supported.
       */
      userref?: number;
      ordertype: components["schemas"]["ordertype"];
      /**
       * @description Order direction (buy/sell)
       * @enum {string}
       */
      type: "buy" | "sell";
      /**
       * @description Order quantity in terms of the base asset
       * > Note: Volume can be specified as `0` for closing margin orders to automatically fill the requisite quantity.
       */
      volume: string;
      /** @description Asset pair `id` or `altname` */
      pair: string;
      /**
       * @description Price
       *
       * * Limit price for `limit` orders
       * * Trigger price for `stop-loss`, `stop-loss-limit`, `take-profit` and `take-profit-limit` orders
       */
      price?: string;
      /**
       * @description Secondary Price
       *
       * * Limit price for `stop-loss-limit` and `take-profit-limit` orders
       *
       * >  Note: Either `price` or `price2` can be preceded by `+`, `-`, or `#` to specify the order price as an offset relative to the last traded price. `+` adds the amount to, and `-` subtracts the amount from the last traded price. `#` will either add or subtract the amount to the last traded price, depending on the direction and order type used. Relative prices can be suffixed with a `%` to signify the relative amount as a percentage.
       */
      price2?: string;
      /**
       * @description Price signal used to trigger `stop-loss`, `stop-loss-limit`, `take-profit` and `take-profit-limit` orders.
       * >  Note: This `trigger` type will as well be used for associated conditional close orders.
       *
       * @default last
       * @enum {string}
       */
      trigger?: "index" | "last";
      /** @description Amount of leverage desired (default = none) */
      leverage?: string;
      /**
       * @description Self trade prevention behavior definition
       * * cancel-newest - if self trade is triggered, arriving order will be canceled.
       * * cancel-oldest - if self trade is triggered, resting order will be canceled.
       * * cancel-both - if self trade is triggered, both arriving and resting orders will be canceled.
       *
       * @default cancel-newest
       * @enum {string}
       */
      stp_type?: "cancel-newest" | "cancel-oldest" | "cancel-both";
      oflags?: components["schemas"]["oflags"];
      /**
       * @description Time-in-force of the order to specify how long it should remain in the order book before being cancelled. GTC (Good-'til-cancelled) is default if the parameter is omitted. IOC (immediate-or-cancel) will immediately execute the amount possible and cancel any remaining balance rather than resting in the book. GTD (good-'til-date), if specified, must coincide with a desired `expiretm`.
       *
       * @default GTC
       * @enum {string}
       */
      timeinforce?: "GTC" | "IOC" | "GTD";
      /**
       * @description Scheduled start time. Can be specified as an absolute timestamp or as a number of seconds in the future.
       *   * `0` now (default)
       *   * `+<n>` schedule start time <n> seconds from now
       *   * `<n>` = unix timestamp of start time
       */
      starttm?: string;
      /**
       * @description Expiration time
       *   * `0` no expiration (default)
       *   * `+<n>` = expire <n> seconds from now, minimum 5 seconds
       *   * `<n>` = unix timestamp of expiration time
       */
      expiretm?: string;
      /**
       * @description Conditional close order type.
       * > Note: [Conditional close orders](https://support.kraken.com/hc/en-us/articles/360038640052-Conditional-Close) are triggered by execution of the primary order in the same quantity and opposite direction, but once triggered are __independent orders__ that may reduce or increase net position.
       *
       * @enum {string}
       */
      "close[ordertype]"?:
        | "limit"
        | "stop-loss"
        | "take-profit"
        | "stop-loss-limit"
        | "take-profit-limit";
      /** @description Conditional close order `price` */
      "close[price]"?: string;
      /** @description Conditional close order `price2` */
      "close[price2]"?: string;
      /** @description RFC3339 timestamp (e.g. 2021-04-01T00:18:45Z) after which the matching engine should reject the new order request, in presence of latency or order queueing. min now() + 2 seconds, max now() + 60 seconds. */
      deadline?: string;
      /**
       * @description Validate inputs only. Do not submit order.
       * @default false
       */
      validate?: boolean;
    };
    "add-2": {
      /** OrderAdded */
      result?: {
        /** @description Order description info */
        descr?: {
          /** @description Order description */
          order?: string;
          /** @description Conditional close order description, if applicable */
          close?: string;
        };
        /**
         * @description Transaction IDs for order
         * <br><sup><sub>(if order was added successfully)</sup></sub>
         */
        txid?: string[];
      };
      error?: components["schemas"]["error"][];
    };
    /** Add Standard Order Request Body */
    batchadd: {
      nonce: components["schemas"]["nonce"];
      orders: {
        /**
         * Format: int32
         * @description User reference id
         * `userref` is an optional user-specified integer id that can be associated with any number of orders. Many clients choose a `userref` corresponding to a unique integer id generated by their systems (e.g. a timestamp). However, because we don't enforce uniqueness on our side, it can also be used to easily group orders by pair, side, strategy, etc. This allows clients to more readily cancel or query information about orders in a particular group, with fewer API calls by using `userref` instead of our `txid`, where supported.
         */
        userref?: number;
        /** @description Order direction (buy/sell) */
        ordertype?: components["schemas"]["ordertype"];
        /**
         * @description Order quantity in terms of the base asset
         * > Note: Volume can be specified as `0` for closing margin orders to automatically fill the requisite quantity.
         */
        volume?: string;
        /**
         * @description Price
         *
         * * Limit price for `limit` orders
         * * Trigger price for `stop-loss`, `stop-loss-limit`, `take-profit` and `take-profit-limit` orders
         */
        price?: string;
        /**
         * @description Secondary Price
         *
         * * Limit price for `stop-loss-limit` and `take-profit-limit` orders
         *
         * >  Note: Either `price` or `price2` can be preceded by `+`, `-`, or `#` to specify the order price as an offset relative to the last traded price. `+` adds the amount to, and `-` subtracts the amount from the last traded price. `#` will either add or subtract the amount to the last traded price, depending on the direction and order type used. Relative prices can be suffixed with a `%` to signify the relative amount as a percentage.
         */
        price2?: string;
        /**
         * @description Price signal used to trigger `stop-loss`, `stop-loss-limit`, `take-profit` and `take-profit-limit` orders.
         * >  Note: This `trigger` type will as well be used for associated conditional close orders.
         *
         * @default last
         * @enum {string}
         */
        trigger?: "index" | "last";
        /** @description Amount of leverage desired (default = none) */
        leverage?: string;
        /**
         * @description Self trade prevention behaviour definition
         * * cancel_newest - if self trade is triggered, arriving order will be canceled.
         * * cancel_oldest - if self trade is triggered, resting order will be canceled.
         * * cancel_both - if self trade is triggered, both arriving and resting orders will be canceled.
         *
         * @default cancel_newest
         * @enum {string}
         */
        stptype?: "cancel_newest" | "cancel_oldest" | "cancel_both";
        oflags?: components["schemas"]["oflags"];
        /**
         * @description Time-in-force of the order to specify how long it should remain in the order book before being cancelled. GTC (Good-'til-cancelled) is default if the parameter is omitted. IOC (immediate-or-cancel) will immediately execute the amount possible and cancel any remaining balance rather than resting in the book. GTD (good-'til-date), if specified, must coincide with a desired `expiretm`.
         *
         * @default GTC
         * @enum {string}
         */
        timeinforce?: "GTC" | "IOC" | "GTD";
        /**
         * @description Scheduled start time. Can be specified as an absolute timestamp or as a number of seconds in the future.
         *  * `0` now (default)
         *  * `+<n>` schedule start time <n> seconds from now
         *  * `<n>` = unix timestamp of start time
         */
        starttm?: string;
        /**
         * @description Expiration time
         *  * `0` no expiration (default)
         *  * `+<n>` = expire <n> seconds from now, minimum 5 seconds
         *  * `<n>` = unix timestamp of expiration time
         */
        expiretm?: string;
      }[];
      /** @description Asset pair `id` or `altname` */
      pair: string;
      /** @description RFC3339 timestamp (e.g. 2021-04-01T00:18:45Z) after which the matching engine should reject the new order request, in presence of latency or order queueing. min now() + 2 seconds, max now() + 60 seconds. */
      deadline?: string;
      /**
       * @description Validate inputs only. Do not submit order.
       * @default false
       */
      validate?: boolean;
    };
    "batchadd-2": {
      /** Result */
      result?: {
        /** Orders */
        orders?: {
          /** @description Order description info */
          descr?: string;
          /** @description Error description from individual order processing */
          error?: string;
          /**
           * @description Transaction ID for order
           * <br><sup><sub>(if order was added successfully)</sup></sub>
           */
          txid?: string;
        }[];
      };
      error?: components["schemas"]["error"][];
    };
    /** Edit Standard Order Request Body */
    edit: {
      nonce: components["schemas"]["nonce"];
      /**
       * Format: int32
       * @description User reference id
       *
       * `userref` is an optional user-specified integer id associated with edit request.
       *  >  Note: userref from parent order will not be retained on the new order after edit.
       */
      userref?: number;
      /** @description Original Order ID or User Reference Id (userref) which is user-specified integer id used with the original order. If userref is not unique and was used with multiple order, edit request is denied with an error. */
      txid: string | number;
      /** @description Order quantity in terms of the base asset. */
      volume?: string;
      /** @description Asset pair `id` or `altname` */
      pair: string;
      /**
       * @description Price
       *
       * * Limit price for `limit` orders
       * * Trigger price for `stop-loss`, `stop-loss-limit`, `take-profit` and `take-profit-limit` orders
       */
      price?: string;
      /**
       * @description Secondary Price
       *
       * * Limit price for `stop-loss-limit` and `take-profit-limit` orders
       *
       * >  Note: Either `price` or `price2` can be preceded by `+`, `-`, or `#` to specify the order price as an offset relative to the last traded price. `+` adds the amount to, and `-` subtracts the amount from the last traded price. `#` will either add or subtract the amount to the last traded price, depending on the direction and order type used. Relative prices can be suffixed with a `%` to signify the relative amount as a percentage.
       */
      price2?: string;
      /** @description Comma delimited list of order flags. Only these flags can be changed: - post post-only order (available when ordertype = limit). All the flags from the parent order are retained except post-only. post-only needs to be explicitly mentioned on edit request. */
      oflags?: unknown;
      /** @description RFC3339 timestamp (e.g. 2021-04-01T00:18:45Z) after which the matching engine should reject the new order request, in presence of latency or order queueing. min now() + 2 seconds, max now() + 60 seconds. */
      deadline?: string;
      /** @description Used to interpret if client wants to receive pending replace, before the order is completely replaced */
      cancel_response?: boolean;
      /**
       * @description Validate inputs only. Do not submit order.
       * @default false
       */
      validate?: boolean;
    };
    "edit-2": {
      /** OrderEdited */
      result?: {
        /** @description Order description info */
        descr?: {
          /** @description Order description */
          order?: string;
        };
        /**
         * @description New Transaction ID
         * <br><sup><sub>(if order was added successfully)</sup></sub>
         */
        txid?: string;
        /** @description Original userref if passed with the request */
        newuserref?: string;
        /** @description Original userref if passed with the request */
        olduserref?: string;
        /** @description Number of orders cancelled (either 0 or 1) */
        orders_cancelled?: number;
        /** @description Original transaction ID */
        originaltxid?: string;
        /** @description Status of the order: Ok or Err */
        status?: string;
        /** @description Updated volume */
        volume?: string;
        /** @description Updated price */
        price?: string;
        /** @description Updated price2 */
        price2?: string;
        /** @description Error message if unsuccessful */
        error_message?: string;
      };
      error?: components["schemas"]["error"][];
    };
    /** Cancel Open Order Request Body */
    cancel: {
      nonce: components["schemas"]["nonce"];
      /** @description Open order transaction ID (txid) or user reference (userref) */
      txid: string | number;
    };
    "cancel-2": {
      /** OrderCancelled */
      result?: {
        /**
         * Format: int32
         * @description Number of orders cancelled.
         */
        count?: number;
        /** @description if set, order(s) is/are pending cancellation */
        pending?: boolean;
      };
      error?: components["schemas"]["error"][];
    };
    /** Batch Cancel Open Orders Request Body */
    batchcancel: {
      nonce: components["schemas"]["nonce"];
      orders: {
        /** @description Open orders transaction ID (txid) or user reference (userref) */
        txid?: string | number;
      }[];
    };
    "batchcancel-2": {
      /** OrdersCancelled */
      result?: {
        /**
         * Format: int32
         * @description Number of orders cancelled.
         */
        count?: number;
      };
      error?: components["schemas"]["error"][];
    };
    /** Get Desposit Methods Request Body */
    methods: {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being deposited */
      asset: string;
    };
    /**
     * depositMethod
     * @description Deposit Method
     */
    method: {
      /** @description Name of deposit method */
      method?: string;
      /** @description Maximum net amount that can be deposited right now, or false if no limit */
      limit?: unknown;
      /** @description Amount of fees that will be paid */
      fee?: string;
      /** @description Whether or not method has an address setup fee */
      "address-setup-fee"?: string;
      /** @description Whether new addresses can be generated for this method. */
      "gen-address"?: boolean;
    };
    "methods-2": {
      result?: components["schemas"]["method"][];
      error?: components["schemas"]["error"];
    };
    addresses: {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being deposited */
      asset: string;
      /** @description Name of the deposit method */
      method: string;
      /**
       * @description Whether or not to generate a new address
       * @default false
       */
      new?: boolean;
    };
    /**
     * depositAddress
     * @description Deposit Address
     */
    address: {
      /** @description Deposit Address */
      address?: string;
      /** @description Expiration time in unix timestamp, or 0 if not expiring */
      expiretm?: string;
      /** @description Whether or not address has ever been used */
      new?: boolean;
    };
    "addresses-2": {
      result?: components["schemas"]["address"][];
      error?: components["schemas"]["error"];
    };
    /** Get Status of Recent Deposits Request Body */
    recent: {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being deposited */
      asset: string;
      /** @description Name of the deposit method */
      method?: string;
    };
    /**
     * Deposit
     * @description Deposit
     */
    deposit: {
      /** @description Name of deposit method */
      method?: string;
      /** @description Asset class */
      aclass?: string;
      /** @description Asset */
      asset?: string;
      /** @description Reference ID */
      refid?: string;
      /** @description Method transaction ID */
      txid?: string;
      /** @description Method transaction information */
      info?: string;
      /** @description Amount deposited */
      amount?: string;
      /** @description Fees paid */
      fee?: unknown;
      /**
       * Format: int32
       * @description Unix timestamp when request was made
       */
      time?: number;
      /**
       * @description Status of deposit<br>
       * <sup><sub>For information about the status, please refer to the [IFEX financial transaction states](https://github.com/globalcitizen/ifex-protocol/blob/master/draft-ifex-00.txt#L837).</sup></sub>
       */
      status?: unknown;
      /**
       * @description Addition status properties <sup><sub>(if available)</sup></sub><br>
       *   * `return` A return transaction initiated by Kraken
       *   * `onhold` Deposit is on hold pending review
       *
       * @enum {string}
       */
      "status-prop"?: "return" | "onhold";
    };
    "recent-2": {
      result?: components["schemas"]["deposit"][];
      error?: components["schemas"]["error"];
    };
    "info-4": {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being withdrawn */
      asset: string;
      /** @description Withdrawal key name, as set up on your account */
      key: string;
      /** @description Amount to be withdrawn */
      amount: string;
    };
    "info-5": {
      /**
       * withdrawalInfo
       * @description Withdrawal Info
       */
      result?: {
        /** @description Name of the withdrawal method that will be used */
        method?: string;
        /** @description Maximum net amount that can be withdrawn right now */
        limit?: string;
        /** @description Net amount that will be sent, after fees */
        amount?: string;
        /** @description Amount of fees that will be paid */
        fee?: string;
      };
      error?: components["schemas"]["error"];
    };
    withdrawal: {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being withdrawn */
      asset: string;
      /** @description Withdrawal key name, as set up on your account */
      key: string;
      /** @description Amount to be withdrawn */
      amount: string;
    };
    "withdrawal-2": {
      result?: {
        /** @description Reference ID */
        refid?: string;
      };
      error?: components["schemas"]["error"];
    };
    /** Get Status of Recent Withdrawals Request Body */
    "recent-3": {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being withdrawn */
      asset: string;
      /** @description Name of the withdrawal method */
      method?: string;
    };
    /**
     * Withdrawal
     * @description Withdrawal
     */
    "withdrawal-3": {
      /** @description Name of withdrawal method */
      method?: string;
      /** @description Asset class */
      aclass?: string;
      /** @description Asset */
      asset?: string;
      /** @description Reference ID */
      refid?: string;
      /** @description Method transaction ID */
      txid?: string;
      /** @description Method transaction information */
      info?: string;
      /** @description Amount withdrawn */
      amount?: string;
      /** @description Fees paid */
      fee?: unknown;
      /**
       * Format: int32
       * @description Unix timestamp when request was made
       */
      time?: number;
      /**
       * @description Status of withdraw<br>
       * <sup><sub>For information about the status, please refer to the [IFEX financial transaction states](https://github.com/globalcitizen/ifex-protocol/blob/master/draft-ifex-00.txt#L837).</sup></sub>
       *
       * @enum {string}
       */
      status?: "Initial" | "Pending" | "Settled" | "Success" | "Failure";
      /**
       * @description Addition status properties <sup><sub>(if available)</sup></sub><br>
       *   * `cancel-pending` cancelation requested
       *   * `canceled` canceled
       *   * `cancel-denied` cancelation requested but was denied
       *   * `return` a return transaction initiated by Kraken; it cannot be canceled
       *   * `onhold` withdrawal is on hold pending review
       *
       * @enum {string}
       */
      "status-prop"?:
        | "cancel-pending"
        | "canceled"
        | "cancel-denied"
        | "return"
        | "onhold";
    };
    "recent-4": {
      result?: components["schemas"]["withdrawal-3"][];
      error?: components["schemas"]["error"];
    };
    /** Request Withdrawal Cancelation Request Body */
    "cancel-3": {
      nonce: components["schemas"]["nonce"];
      /** @description Asset being withdrawn */
      asset: string;
      /** @description Withdrawal reference ID */
      refid: string;
    };
    lock: {
      /** @description Days the funds are locked. */
      days: number;
      /** @description Percentage of the funds that are locked (0 - 100) */
      percentage: number;
    };
    /** Staking Asset Information */
    asset: {
      /** @description Asset code/name */
      asset: string;
      /** @description Staking asset code/name */
      staking_asset: string;
      /** @description Unique ID of the staking option (used in Stake/Unstake operations) */
      method?: string;
      /**
       * @description Whether the staking operation is on-chain or not.
       * @default true
       */
      on_chain?: boolean;
      /**
       * @description Whether the user will be able to stake this asset.
       * @default true
       */
      can_stake?: boolean;
      /**
       * @description Whether the user will be able to unstake this asset.
       * @default true
       */
      can_unstake?: boolean;
      /** @description Minimium amounts for staking/unstaking. */
      minimum_amount?: {
        /** @default 0 */
        unstaking: string;
        /** @default 0 */
        staking: string;
      };
      /** @description Describes the locking periods and percentages for staking/unstaking operations. */
      lock?: {
        unstaking?: components["schemas"]["lock"][];
        staking?: components["schemas"]["lock"][];
        lockup?: components["schemas"]["lock"][];
      };
      /** @default true */
      enabled_for_user?: boolean;
      disabled?: boolean;
      /** @description Describes the rewards earned while staking. */
      rewards: {
        /** @description Reward earned while staking */
        reward?: string;
        /**
         * @description Reward type
         * @enum {string}
         */
        type?: "percentage";
      };
    };
    /** Staking Transaction Info */
    transaction: {
      /** @description The reference ID of the transaction. */
      refid?: string;
      /**
       * @description The type of transaction.
       * @enum {string}
       */
      type?: "bonding" | "reward" | "unbonding";
      /** @description Asset code/name */
      asset?: string;
      /** @description The transaction amount */
      amount?: string;
      /** @description Unix timestamp when the transaction was initiated. */
      time?: number;
      /** @description Unix timestamp from the start of bond period (applicable only to `bonding` transactions). */
      bond_start?: number;
      /** @description Unix timestamp of the end of bond period (applicable only to `bonding` transactions). */
      bond_end?: number;
      /**
       * @description Transaction status
       * @enum {string}
       */
      status?: "Initial" | "Pending" | "Settled" | "Success" | "Failure";
    };
  };
  parameters: {
    /**
     * @description Comma delimited list of assets to get info on.
     * @example XBT,ETH
     */
    asset: string;
    /**
     * @description Asset class.  (optional, default: `currency`)
     * @example currency
     */
    aclass: string;
    /**
     * @description Asset pair to get data for
     * @example XBTUSD
     */
    pair: string;
  };
  requestBodies: {
    nonceOnly: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
        };
      };
    };
    balance: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Base asset used to determine balance
           * @default ZUSD
           */
          asset?: string;
        };
      };
    };
    openOrders: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Whether or not to include trades related to position in output
           * @default false
           */
          trades?: boolean;
          /**
           * Format: int32
           * @description Restrict results to given user reference id
           */
          userref?: number;
        };
      };
    };
    closedOrders: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Whether or not to include trades related to position in output
           * @default false
           */
          trades?: boolean;
          /**
           * Format: int32
           * @description Restrict results to given user reference id
           */
          userref?: number;
          /** @description Starting unix timestamp or order tx ID of results (exclusive) */
          start?: number;
          /** @description Ending unix timestamp or order tx ID of results (inclusive) */
          end?: number;
          /** @description Result offset for pagination */
          ofs?: number;
          /**
           * @description Which time to use to search
           * @default both
           * @enum {string}
           */
          closetime?: "open" | "close" | "both";
        };
      };
    };
    history: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Type of trade
           * @default all
           * @enum {string}
           */
          type?:
            | "all"
            | "any position"
            | "closed position"
            | "closing position"
            | "no position";
          /**
           * @description Whether or not to include trades related to position in output
           * @default false
           */
          trades?: boolean;
          /** @description Starting unix timestamp or trade tx ID of results (exclusive) */
          start?: number;
          /** @description Ending unix timestamp or trade tx ID of results (inclusive) */
          end?: number;
          /** @description Result offset for pagination */
          ofs?: number;
        };
      };
    };
    query: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Comma delimited list of transaction IDs to query info about (20 maximum) */
          txid?: string;
          /**
           * @description Whether or not to include trades related to position in output
           * @default false
           */
          trades?: boolean;
        };
      };
    };
    info: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Comma delimited list of assets to restrict output to
           * @default all
           */
          asset?: string;
          /**
           * @description Asset class
           * @default currency
           */
          aclass?: string;
          /**
           * @description Type of ledger to retrieve
           * @default all
           * @enum {string}
           */
          type?:
            | "all"
            | "deposit"
            | "withdrawal"
            | "trade"
            | "margin"
            | "rollover"
            | "credit"
            | "transfer"
            | "settled"
            | "staking"
            | "sale";
          /** @description Starting unix timestamp or ledger ID of results (exclusive) */
          start?: number;
          /** @description Ending unix timestamp or ledger ID of results (inclusive) */
          end?: number;
          /** @description Result offset for pagination */
          ofs?: number;
        };
      };
    };
    "query-2": {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Comma delimited list of ledger IDs to query info about (20 maximum) */
          id?: string;
          /**
           * @description Whether or not to include trades related to position in output
           * @default false
           */
          trades?: boolean;
        };
      };
    };
    volume: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Comma delimited list of asset pairs to get fee info on (optional) */
          pair?: string;
          /** @description Whether or not to include fee info in results (optional) */
          "fee-info"?: boolean;
        };
      };
    };
  };
}

export interface operations {
  /** Get the server's time. */
  getServerTime: {
    responses: {
      /** Success response */
      200: {
        content: {
          "application/json": components["schemas"]["time"];
        };
      };
    };
  };
  /** Get the current system status or trading mode. */
  getSystemStatus: {
    responses: {
      /** Success response */
      200: {
        content: {
          "application/json": {
            result?: {
              /**
               * @description Current system status
               *
               * * `online`  Kraken is operating normally. All order types may be submitted and trades can occur.
               * * `maintenance`  The exchange is offline. No new orders or cancellations may be submitted.
               * * `cancel_only`  Resting (open) orders can be cancelled but no new orders may be submitted. No trades will occur.
               * * `post_only`  Only post-only limit orders can be submitted. Existing orders may still be cancelled. No trades will occur.
               *
               * @enum {string}
               */
              status?: "online" | "maintenance" | "cancel_only" | "post_only";
              /** @description Current timestamp (RFC3339) */
              timestamp?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
  };
  /** Get information about the assets that are available for deposit, withdrawal, trading and staking. */
  getAssetInfo: {
    parameters: {
      query: {
        /** Comma delimited list of assets to get info on. */
        asset?: components["parameters"]["asset"];
        /** Asset class.  (optional, default: `currency`) */
        aclass?: components["parameters"]["aclass"];
      };
    };
    responses: {
      /** Asset info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["info-2"];
        };
      };
    };
  };
  /** Get tradable asset pairs */
  getTradableAssetPairs: {
    parameters: {
      query: {
        /** Asset pairs to get data for */
        pair?: string;
        /**
         * Info to retrieve.  (optional)
         *
         *   * `info` = all info
         *   * `leverage` = leverage info
         *   * `fees` = fees schedule
         *   * `margin` = margin info
         */
        info?: "info" | "leverage" | "fees" | "margin";
      };
    };
    responses: {
      /** Tradable asset pairs retrieved. */
      200: {
        content: {
          "application/json": {
            /** @description Pair names and their info */
            result?: { [key: string]: components["schemas"]["pairs"] };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
  };
  /** Note: Today's prices start at midnight UTC */
  getTickerInformation: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
      };
    };
    responses: {
      /** Ticker info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ticker-2"];
        };
      };
    };
  };
  /** Note: the last entry in the OHLC array is for the current, not-yet-committed frame and will always be present, regardless of the value of `since`. */
  getOHLCData: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
        /** Time frame interval in minutes */
        interval?: 1 | 5 | 15 | 30 | 60 | 240 | 1440 | 10080 | 21600;
        /** Return up to 720 OHLC data points since given timestamp . */
        since?: number;
      };
    };
    responses: {
      /** OHLC data retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ohlc"];
        };
      };
    };
  };
  getOrderBook: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
        /** maximum number of asks/bids */
        count?: number;
      };
    };
    responses: {
      /** Order book entries retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["depth"];
        };
      };
    };
  };
  /** Returns the last 1000 trades by default */
  getRecentTrades: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
        /** Return trade data since given timestamp */
        since?: string;
      };
    };
    responses: {
      /** Trade data retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["trades"];
        };
      };
    };
  };
  getRecentSpreads: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
        /** Return spread data since given ID */
        since?: number;
      };
    };
    responses: {
      /** Spread data retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["spread-2"];
        };
      };
    };
  };
  /**
   * An authentication token must be requested via this REST API endpoint in order to connect to and authenticate with our [Websockets API](https://docs.kraken.com). The token should be used within 15 minutes of creation, but it does not expire once a successful Websockets connection and private subscription has been made and is maintained.
   *
   * > The 'Access WebSockets API' permission must be enabled for the API key in order to generate the authentication token.
   */
  getWebsocketsToken: {
    responses: {
      /** Websockets token retrieved. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Websockets token */
              token?: string;
              /** @description Time (in seconds) after which the token expires */
              expires?: number;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: components["requestBodies"]["nonceOnly"];
  };
  /** Retrieve all cash balances, net of pending withdrawals. */
  getAccountBalance: {
    responses: {
      /** Account balances retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["balance-2"];
        };
      };
    };
    requestBody: components["requestBodies"]["nonceOnly"];
  };
  /** Retrieve a summary of collateral balances, margin position valuations, equity and margin level. */
  getTradeBalance: {
    responses: {
      /** Trade balances retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["balance-4"];
        };
      };
    };
    requestBody: components["requestBodies"]["balance"];
  };
  /** Retrieve information about currently open orders. */
  getOpenOrders: {
    responses: {
      /** Open orders info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["open-2"];
        };
      };
    };
    requestBody: components["requestBodies"]["openOrders"];
  };
  /**
   * Retrieve information about orders that have been closed (filled or cancelled). 50 results are returned at a time, the most recent by default.
   *
   * **Note:** If an order's tx ID is given for `start` or `end` time, the order's opening time (`opentm`) is used
   */
  getClosedOrders: {
    responses: {
      /** Closed orders info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["closed-2"];
        };
      };
    };
    requestBody: components["requestBodies"]["closedOrders"];
  };
  /** Retrieve information about specific orders. */
  getOrdersInfo: {
    responses: {
      /** Orders info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["query-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["query"];
      };
    };
  };
  /**
   * Retrieve information about trades/fills. 50 results are returned at a time, the most recent by default.
   * * Unless otherwise stated, costs, fees, prices, and volumes are specified with the precision for the asset pair (`pair_decimals` and `lot_decimals`), not the individual assets' precision (`decimals`).
   */
  getTradeHistory: {
    responses: {
      /** Trade history retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["history-2"];
        };
      };
    };
    requestBody: components["requestBodies"]["history"];
  };
  /** Retrieve information about specific trades/fills. */
  getTradesInfo: {
    responses: {
      /** Trades info retrieved. */
      200: {
        content: {
          "application/json": {
            /** @description Trade info */
            result?: { [key: string]: components["schemas"]["trade-2"] };
            error?: components["schemas"]["error"][];
          };
        };
      };
    };
    requestBody: components["requestBodies"]["query"];
  };
  /** Get information about open margin positions. */
  getOpenPositions: {
    responses: {
      /** Open positions info retrieved. */
      200: {
        content: {
          "application/json": {
            result?: {
              [key: string]: {
                /** @description Order ID responsible for the position */
                ordertxid?: string;
                /**
                 * @description Position status
                 * @enum {string}
                 */
                posstatus?: "open";
                /** @description Asset pair */
                pair?: string;
                /** @description Unix timestamp of trade */
                time?: number;
                /** @description Direction (buy/sell) of position */
                type?: string;
                /** @description Order type used to open position */
                ordertype?: string;
                /** @description Opening cost of position (in quote currency) */
                cost?: string;
                /** @description Opening fee of position (in quote currency) */
                fee?: string;
                /** @description Position opening size (in base currency) */
                vol?: string;
                /** @description Quantity closed (in base currency) */
                vol_closed?: string;
                /** @description Initial margin consumed (in quote currency) */
                margin?: string;
                /** @description Current value of remaining position (if `docalcs` requested) */
                value?: string;
                /** @description Unrealised P&L of remaining position (if `docalcs` requested) */
                net?: string;
                /** @description Funding cost and term of position */
                terms?: string;
                /** @description Timestamp of next margin rollover fee */
                rollovertm?: string;
                /** @description Comma delimited list of add'l info */
                misc?: string;
                /** @description Comma delimited list of opening order flags */
                oflags?: string;
              };
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Comma delimited list of txids to limit output to */
          txid?: string;
          /**
           * @description Whether to include P&L calculations
           * @default false
           */
          docalcs?: boolean;
          /**
           * @description Consolidate positions by market/pair
           * @enum {string}
           */
          consolidation?: "market";
        };
      };
    };
  };
  /** Retrieve information about ledger entries. 50 results are returned at a time, the most recent by default. */
  getLedgers: {
    responses: {
      /** Ledgers info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["info-3"];
        };
      };
    };
    requestBody: components["requestBodies"]["info"];
  };
  /** Retrieve information about specific ledger entries. */
  getLedgersInfo: {
    responses: {
      /** Ledgers info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["query-3"];
        };
      };
    };
    requestBody: components["requestBodies"]["query-2"];
  };
  /** Note: If an asset pair is on a maker/taker fee schedule, the taker side is given in `fees` and maker side in `fees_maker`. For pairs not on maker/taker, they will only be given in `fees`. */
  getTradeVolume: {
    parameters: {
      query: {
        /** Asset pair to get data for */
        pair: components["parameters"]["pair"];
      };
    };
    responses: {
      /** Trade Volume retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["volume"];
        };
      };
    };
    requestBody: components["requestBodies"]["volume"];
  };
  /** Request export of trades or ledgers. */
  addExport: {
    responses: {
      /** Export request made */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Report ID */
              id?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Type of data to export
           * @enum {string}
           */
          report: "trades" | "ledgers";
          /**
           * @description File format to export
           * @default CSV
           * @enum {string}
           */
          format?: "CSV" | "TSV";
          /** @description Description for the export */
          description: string;
          /**
           * @description Comma-delimited list of fields to include
           *
           * * `trades`: ordertxid, time, ordertype, price, cost, fee, vol, margin, misc, ledgers
           * * `ledgers`: refid, time, type, aclass, asset, amount, fee, balance
           *
           * @default all
           */
          fields?: string;
          /** @description UNIX timestamp for report start time (default 1st of the current month) */
          starttm?: number;
          /** @description UNIX timestamp for report end time (default now) */
          endtm?: number;
        };
      };
    };
  };
  /** Get status of requested data exports. */
  exportStatus: {
    responses: {
      /** Export status retrieved */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Report ID */
              id?: string;
              descr?: string;
              format?: string;
              report?: string;
              subtype?: string;
              /**
               * @description Status of the report
               * @enum {string}
               */
              status?: "Queued" | "Processing" | "Processed";
              /** @deprecated */
              flags?: string;
              fields?: string;
              /** @description UNIX timestamp of report request */
              createdtm?: string;
              /** @deprecated */
              expiretm?: string;
              /** @description UNIX timestamp report processing began */
              starttm?: string;
              /** @description UNIX timestamp report processing finished */
              completedtm?: string;
              /** @description UNIX timestamp of the report data start time */
              datastarttm?: string;
              /** @description UNIX timestamp of the report data end time */
              dataendtm?: string;
              /** @deprecated */
              aclass?: string;
              asset?: string;
            }[];
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Type of reports to inquire about
           * @enum {string}
           */
          report: "trades" | "ledgers";
        };
      };
    };
  };
  /** Retrieve a processed data export */
  retrieveExport: {
    responses: {
      /** Data export report retrieved */
      200: {
        content: {
          "application/octet-stream": {
            /**
             * Format: binary
             * @description Binary zip archive containing the report
             */
            report?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Report ID to retrieve */
          id: string;
        };
      };
    };
  };
  /** Delete exported trades/ledgers report */
  removeExport: {
    responses: {
      /** Export report deleted or cancelled */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Whether deletion was successful */
              delete?: boolean;
              /** @description Whether cancellation was successful */
              cancel?: boolean;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description ID of report to delete or cancel */
          id: string;
          /**
           * @description `delete` can only be used for reports that have already been processed. Use `cancel` for queued or processing reports.
           *
           * @enum {string}
           */
          type: "cancel" | "delete";
        };
      };
    };
  };
  /**
   * Place a new order.
   *
   * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
   */
  addOrder: {
    responses: {
      /** Order added. */
      200: {
        content: {
          "application/json": components["schemas"]["add-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["add"];
      };
    };
  };
  /**
   * Send an array of orders (max: 15).
   * Any orders rejected due to order validations, will be dropped and the rest of the batch is processed. All orders in batch should be limited to a single pair.
   * The order of returned txid's in the response array is the same as the order of the order list sent in request.
   *
   * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
   */
  addOrderBatch: {
    responses: {
      /** Orders added. */
      200: {
        content: {
          "application/json": components["schemas"]["batchadd-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["batchadd"];
      };
    };
  };
  /**
   * Edit volume and price on open orders. Uneditable orders include margin orders, triggered stop/profit orders, orders with conditional close terms attached, those already cancelled or filled, and those where the executed volume is greater than the newly supplied volume. post-only flag is not retained from original order after successful edit. post-only needs to be explicitly set on edit request.
   *
   * **Note**: See the [AssetPairs](#operation/getTradableAssetPairs) endpoint for details on the available trading pairs, their price and quantity precisions, order minimums, available leverage, etc.
   */
  editOrder: {
    responses: {
      /** Order edited. */
      200: {
        content: {
          "application/json": components["schemas"]["edit-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["edit"];
      };
    };
  };
  /** Cancel a particular open order (or set of open orders) by `txid` or `userref` */
  cancelOrder: {
    responses: {
      /** Open order cancelled. */
      200: {
        content: {
          "application/json": components["schemas"]["cancel-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["cancel"];
      };
    };
  };
  /** Cancel all open orders */
  cancelAllOrders: {
    responses: {
      /** Open orders cancelled. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Number of orders that were cancelled */
              count?: number;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: components["requestBodies"]["nonceOnly"];
  };
  /**
   * CancelAllOrdersAfter provides a "Dead Man's Switch" mechanism to protect the client from network malfunction, extreme latency or unexpected matching engine downtime. The client can send a request with a timeout (in seconds), that will start a countdown timer which will cancel *all* client orders when the timer expires. The client has to keep sending new requests to push back the trigger time, or deactivate the mechanism by specifying a timeout of 0. If the timer expires, all orders are cancelled and then the timer remains disabled until the client provides a new (non-zero) timeout.
   *
   * The recommended use is to make a call every 15 to 30 seconds, providing a timeout of 60 seconds. This allows the client to keep the orders in place in case of a brief disconnection or transient delay, while keeping them safe in case of a network breakdown. It is also recommended to disable the timer ahead of regularly scheduled trading engine maintenance (if the timer is enabled, all orders will be cancelled when the trading engine comes back from downtime - planned or otherwise).
   */
  cancelAllOrdersAfter: {
    responses: {
      /** Dead man's switch timer reset or disabled. */
      200: {
        content: {
          "application/json": {
            result?: {
              /** @description Timestamp (RFC3339 format) at which the request was received */
              currentTime?: string;
              /** @description Timestamp (RFC3339 format) after which all orders will be cancelled, unless the timer is extended or disabled */
              triggerTime?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /** @description Duration (in seconds) to set/extend the timer by */
          timeout: number;
        };
      };
    };
  };
  /** Cancel multiple open orders  by `txid` or `userref` */
  cancelOrderBatch: {
    responses: {
      /** Open order cancelled. */
      200: {
        content: {
          "application/json": components["schemas"]["batchcancel-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["batchcancel"];
      };
    };
  };
  /** Retrieve methods available for depositing a particular asset. */
  getDepositMethods: {
    responses: {
      /** Deposit methods retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["methods-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["methods"];
      };
    };
  };
  /** Retrieve (or generate a new) deposit addresses for a particular asset and method. */
  getDepositAddresses: {
    responses: {
      /** Deposit addresses retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["addresses-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["addresses"];
      };
    };
  };
  /** Retrieve information about recent deposits made. */
  getStatusRecentDeposits: {
    responses: {
      /** Recent deposits retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["recent-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["recent"];
      };
    };
  };
  /** Retrieve fee information about potential withdrawals for a particular asset, key and amount. */
  getWithdrawalInformation: {
    responses: {
      /** Withdrawal information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["info-5"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["info-4"];
      };
    };
  };
  /** Make a withdrawal request. */
  withdrawFunds: {
    responses: {
      /** Withdrawal created. */
      200: {
        content: {
          "application/json": components["schemas"]["withdrawal-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["withdrawal"];
      };
    };
  };
  /** Retrieve information about recently requests withdrawals. */
  getStatusRecentWithdrawals: {
    responses: {
      /** Recent withdrawals retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["recent-4"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["recent-3"];
      };
    };
  };
  /** Cancel a recently requested withdrawal, if it has not already been successfully processed. */
  cancelWithdrawal: {
    responses: {
      /** Withdrawal cancellation requested. */
      200: {
        content: {
          "application/json": {
            /** @description Whether cancellation was successful or not. */
            result?: boolean;
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["cancel-3"];
      };
    };
  };
  /** Transfer from Kraken spot wallet to Kraken Futures holding wallet. Note that a transfer in the other direction must be requested via the Kraken Futures [API endpoint](https://support.kraken.com/hc/en-us/articles/360028105972-Withdrawal-to-Spot-Wallet). */
  walletTransfer: {
    responses: {
      /** Transfer created. */
      200: {
        content: {
          "application/json": {
            result?: {
              /**
               * @description Reference ID
               * @example BOG5AE5-KSCNR4-VPNPEV
               */
              refid?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Asset to transfer (asset ID or `altname`)
           * @example XBT
           */
          asset: string;
          /**
           * @description Source wallet
           * @enum {string}
           */
          from: "Spot Wallet";
          /**
           * @description Destination wallet
           * @enum {string}
           */
          to: "Futures Wallet";
          /** @description Amount to transfer */
          amount: string;
        };
      };
    };
  };
  /** Stake an asset from your spot wallet. This operation requires an API key with `Withdraw funds` permission. */
  stake: {
    responses: {
      /** Staking successful. */
      200: {
        content: {
          "application/json": {
            result?: {
              /**
               * @description Reference ID
               * @example BOG5AE5-KSCNR4-VPNPEV
               */
              refid?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Asset to stake (asset ID or `altname`)
           * @example XBT
           */
          asset: string;
          /** @description Amount of the asset to stake */
          amount: string;
          /** @description Name of the staking option to use (refer to the Staking Assets endpoint for the correct method names for each asset) */
          method: string;
        };
      };
    };
  };
  /** Unstake an asset from your staking wallet. This operation requires an API key with `Withdraw funds` permission. */
  unstake: {
    responses: {
      /** Unstaking successful. */
      200: {
        content: {
          "application/json": {
            result?: {
              /**
               * @description Reference ID
               * @example BOG5AE5-KSCNR4-VPNPEV
               */
              refid?: string;
            };
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
          /**
           * @description Asset to unstake (asset ID or `altname`). Must be a valid staking asset (e.g. `XBT.M`, `XTZ.S`, `ADA.S`)
           * @example XBT.M
           */
          asset: string;
          /** @description Amount of the asset to stake */
          amount: string;
        };
      };
    };
  };
  /**
   * Returns the list of assets that the user is able to stake. This operation
   * requires an API key with both `Withdraw funds` and `Query funds` permission.
   */
  getStakingAssetInfo: {
    responses: {
      /** List of stakeable assets retrieved successfully. */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["asset"][];
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
        };
      };
    };
  };
  /**
   * Returns the list of pending staking transactions. Once resolved, these transactions
   * will appear on the `List of Staking Transactions` endpoint.
   *
   * This operation requires an API key with both `Query funds` and `Withdraw funds` permissions.
   */
  getStakingPendingDeposits: {
    responses: {
      /** Pending transactions retrieved successfully. */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["transaction"][];
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
        };
      };
    };
  };
  /**
   * Returns the list of 1000 recent staking transactions from past 90 days.
   *
   * This operation requires an API key with `Query funds` permissions.
   */
  getStakingTransactions: {
    responses: {
      /** List of transactions retrieved successfully. */
      200: {
        content: {
          "application/json": {
            result?: components["schemas"]["transaction"][];
            error?: components["schemas"]["error"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          nonce: components["schemas"]["nonce"];
        };
      };
    };
  };
}
